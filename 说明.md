# Java 计算器代码详解手册（新手版）

> 📘 本手册专为 Java 初学者编写，详细讲解每个类、方法的工作原理和实现细节。

---

## 📚 目录

1. [项目整体架构](#项目整体架构)
2. [核心概念讲解](#核心概念讲解)
3. [CasioCalculator 主类详解](#casiocalculator-主类详解)
4. [CalculatorEngine 计算引擎详解](#calculatorengine-计算引擎详解)
5. [MatrixCalculator 矩阵计算器详解](#matrixcalculator-矩阵计算器详解)
6. [GraphPlotter 图形绘制器详解](#graphplotter-图形绘制器详解)
7. [关键技术深入解析](#关键技术深入解析)
8. [实战练习](#实战练习)

---

## 项目整体架构

### 🏗️ MVC 设计模式

本项目采用 MVC（Model-View-Controller）设计模式：

```
┌─────────────────────────────────────────────────┐
│                  用户界面 (View)                 │
│            CasioCalculator.java                 │
│  - 显示屏、按钮、选项卡                          │
│  - 处理用户输入（点击、输入）                     │
└──────────────────┬──────────────────────────────┘
                   │
                   ↓
┌─────────────────────────────────────────────────┐
│              控制器 (Controller)                 │
│            CasioCalculator.java                 │
│  - handleButtonClick() 处理按钮事件              │
│  - 协调 View 和 Model                           │
└──────────────────┬──────────────────────────────┘
                   │
                   ↓
┌─────────────────────────────────────────────────┐
│                模型 (Model)                      │
│  ├─ CalculatorEngine.java (计算逻辑)            │
│  ├─ MatrixCalculator.java (矩阵运算)            │
│  └─ GraphPlotter.java (图形绘制)                │
└─────────────────────────────────────────────────┘
```

### 📦 类之间的关系

```java
CasioCalculator (主类)
    ├── 持有 → CalculatorEngine (计算引擎)
    ├── 使用 → MatrixCalculator (矩阵计算)
    └── 创建 → GraphPlotter (图形绘制)
```

---

## 核心概念讲解

### 1. Java Swing 基础

**Swing 是什么？**
- Java 的 GUI（图形用户界面）工具包
- 用于创建窗口、按钮、文本框等可视化组件

**核心组件：**

```java
// JFrame: 窗口容器（最外层）
JFrame frame = new JFrame("标题");

// JPanel: 面板容器（用于组织组件）
JPanel panel = new JPanel();

// JButton: 按钮
JButton button = new JButton("点击我");

// JTextArea: 多行文本框
JTextArea textArea = new JTextArea();

// JTextField: 单行文本框
JTextField textField = new JTextField();
```

### 2. 布局管理器

**布局管理器决定组件如何排列：**

```java
// BorderLayout: 边界布局（上下左右中）
new BorderLayout()
┌──────────────────┐
│      NORTH       │
├────┬────────┬────┤
│WEST│ CENTER │EAST│
├────┴────────┴────┤
│      SOUTH       │
└──────────────────┘

// GridLayout: 网格布局（m行n列）
new GridLayout(3, 3)  // 3行3列
┌───┬───┬───┐
│ 1 │ 2 │ 3 │
├───┼───┼───┤
│ 4 │ 5 │ 6 │
├───┼───┼───┤
│ 7 │ 8 │ 9 │
└───┴───┴───┘
```

### 3. 事件处理

**Java 中的事件驱动编程：**

```java
// 用户点击按钮 → 触发事件 → 执行处理方法

button.addActionListener(e -> {
    // 这里的代码在按钮被点击时执行
    System.out.println("按钮被点击了！");
});
```

**Lambda 表达式简化写法：**

```java
// 传统写法（匿名内部类）
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("点击");
    }
});

// Lambda 表达式（Java 8+）
button.addActionListener(e -> System.out.println("点击"));
```

---

## CasioCalculator 主类详解

### 📋 类成员变量

```java
public class CasioCalculator extends JFrame {
    // 显示屏 - 显示计算过程和结果
    private JTextArea display;
    
    // 选项卡面板 - 切换不同功能模式
    private JTabbedPane tabbedPane;
    
    // 计算引擎 - 处理所有计算逻辑
    private CalculatorEngine engine;
    
    // 状态标签 - 显示当前状态（角度模式、内存等）
    private JLabel statusLabel;
    
    // 矩阵输入框 - 存储矩阵 A 和 B 的输入字段
    private JTextField[][] matrixAFields;  // 3×3 矩阵
    private JTextField[][] matrixBFields;  // 3×3 矩阵
}
```

**为什么用 `private`？**
- 封装原则：外部无法直接访问，只能通过方法
- 数据安全：防止被意外修改

### 🏗️ 构造函数

```java
public CasioCalculator() {
    // 1. 创建计算引擎实例
    engine = new CalculatorEngine();
    
    // 2. 初始化矩阵输入框数组（3×3）
    matrixAFields = new JTextField[3][3];
    matrixBFields = new JTextField[3][3];
    
    // 3. 初始化用户界面
    initializeUI();
}
```

**执行流程：**
```
创建 CasioCalculator 对象
    ↓
new CalculatorEngine() → 创建计算引擎
    ↓
初始化数组 → 分配内存空间
    ↓
initializeUI() → 构建整个界面
```

### 🎨 initializeUI() - 界面初始化

```java
private void initializeUI() {
    // 1. 设置窗口基本属性
    setTitle("CASIO fx-991CN X - Java Edition");  // 窗口标题
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 关闭操作
    setSize(1000, 750);                            // 窗口大小
    setLocationRelativeTo(null);                   // 居中显示
    
    // 2. 创建主面板
    JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
    mainPanel.setBackground(new Color(40, 40, 40));  // 深灰背景
    mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15)); // 内边距
    
    // 3. 添加组件到主面板
    mainPanel.add(createTopBar(), BorderLayout.NORTH);    // 顶部栏
    mainPanel.add(createDisplay(), BorderLayout.CENTER);  // 显示屏
    
    // 4. 创建选项卡
    tabbedPane = new JTabbedPane();
    tabbedPane.addTab("普通计算", createNormalPanel());
    tabbedPane.addTab("矩阵运算", createMatrixPanel());
    tabbedPane.addTab("方程求解", createEquationPanel());
    tabbedPane.addTab("函数绘图", createGraphPanel());
    
    mainPanel.add(tabbedPane, BorderLayout.SOUTH);  // 添加到底部
    
    // 5. 将主面板添加到窗口
    add(mainPanel);
}
```

**BorderLayout 位置说明：**
```
┌────────────────────────────────┐
│   NORTH (顶部栏)                │  ← createTopBar()
├────────────────────────────────┤
│                                │
│   CENTER (显示屏)               │  ← createDisplay()
│                                │
├────────────────────────────────┤
│   SOUTH (选项卡面板)            │  ← tabbedPane
└────────────────────────────────┘
```

### 🎯 createTopBar() - 创建顶部栏

```java
private JPanel createTopBar() {
    // 1. 创建面板，使用 BorderLayout
    JPanel panel = new JPanel(new BorderLayout());
    panel.setBackground(new Color(20, 50, 100));  // 蓝色背景
    panel.setBorder(new EmptyBorder(12, 20, 12, 20));  // 内边距
    
    // 2. 创建品牌标签（左侧）
    JLabel brand = new JLabel("CASIO fx-991CN X");
    brand.setFont(new Font("Arial", Font.BOLD, 20));
    brand.setForeground(Color.WHITE);  // 白色文字
    
    // 3. 创建状态标签（右侧）
    statusLabel = new JLabel("DEG | M: 0");
    statusLabel.setFont(new Font("Consolas", Font.PLAIN, 12));
    statusLabel.setForeground(new Color(150, 200, 255));  // 浅蓝色
    
    // 4. 添加到面板
    panel.add(brand, BorderLayout.WEST);      // 左侧
    panel.add(statusLabel, BorderLayout.EAST); // 右侧
    
    return panel;
}
```

**效果图：**
```
┌──────────────────────────────────────────┐
│ CASIO fx-991CN X          DEG | M: 0     │
│ ←─────左侧────────┘  └───────右侧─────→  │
└──────────────────────────────────────────┘
```

### 📺 createDisplay() - 创建显示屏

```java
private JScrollPane createDisplay() {
    // 1. 创建文本区域（4行，40列）
    display = new JTextArea(4, 40);
    
    // 2. 设置显示属性
    display.setFont(new Font("Consolas", Font.BOLD, 22));
    display.setBackground(new Color(180, 255, 180));  // 浅绿色（LCD风格）
    display.setForeground(new Color(0, 60, 0));       // 深绿色文字
    display.setEditable(true);                        // 可编辑
    display.setText("0");                             // 初始显示 0
    display.setLineWrap(true);                        // 自动换行
    display.setMargin(new Insets(10, 15, 10, 15));   // 文字边距
    
    // 3. 添加滚动条
    JScrollPane scrollPane = new JScrollPane(display);
    scrollPane.setBorder(new LineBorder(new Color(0, 100, 0), 4));
    
    return scrollPane;
}
```

**Insets 边距说明：**
```java
new Insets(上, 左, 下, 右)
new Insets(10, 15, 10, 15)

┌──────────────────┐
│  ← 15 →          │ ↑ 10
│         文字      │
│                  │ ↓ 10
└──────────────────┘
```

### 🔢 createNormalPanel() - 创建普通计算面板

```java
private JPanel createNormalPanel() {
    // 1. 创建主面板
    JPanel panel = new JPanel(new BorderLayout(8, 8));
    panel.setBackground(new Color(40, 40, 40));
    panel.setBorder(new EmptyBorder(12, 12, 12, 12));
    
    // 2. 创建按钮面板（8行5列网格）
    JPanel buttonsPanel = new JPanel(new GridLayout(8, 5, 6, 6));
    buttonsPanel.setBackground(new Color(40, 40, 40));
    
    // 3. 定义所有按钮布局
    String[][] allButtons = {
        // 第1行：三角函数和基本函数
        {"sin", "cos", "tan", "√", "x²"},
        
        // 第2行：对数和指数函数
        {"ln", "log", "eˣ", "|x|", "x!"},
        
        // 第3行：括号和常数
        {"(", ")", "π", "e", "^"},
        
        // 第4行：清除和基本运算
        {"AC", "DEL", "ANS", "÷", "%"},
        
        // 第5-8行：数字键盘
        {"7", "8", "9", "×", "1/x"},
        {"4", "5", "6", "-", "x³"},
        {"1", "2", "3", "+", "∛"},
        {"0", ".", "(−)", "=", "EXP"}
    };
    
    // 4. 创建所有按钮
    for (String[] row : allButtons) {
        for (String text : row) {
            // 根据文本确定按钮类型
            ButtonType type = determineButtonType(text);
            // 创建并添加按钮
            buttonsPanel.add(createStyledButton(text, type));
        }
    }
    
    panel.add(buttonsPanel, BorderLayout.CENTER);
    
    // 5. 创建内存操作按钮行
    JPanel memoryPanel = new JPanel(new GridLayout(1, 5, 6, 6));
    String[] memButtons = {"MC", "MR", "M+", "M-", "MS"};
    for (String text : memButtons) {
        memoryPanel.add(createStyledButton(text, ButtonType.MEMORY));
    }
    panel.add(memoryPanel, BorderLayout.SOUTH);
    
    return panel;
}
```

**按钮布局可视化：**
```
┌────┬────┬────┬────┬────┐
│sin │cos │tan │ √  │ x² │  第1行：科学函数
├────┼────┼────┼────┼────┤
│ ln │log │ eˣ │|x| │ x! │  第2行：对数指数
├────┼────┼────┼────┼────┤
│ (  │ )  │ π  │ e  │ ^  │  第3行：括号常数
├────┼────┼────┼────┼────┤
│ AC │DEL │ANS │ ÷  │ %  │  第4行：特殊功能
├────┼────┼────┼────┼────┤
│ 7  │ 8  │ 9  │ ×  │1/x │  第5行
├────┼────┼────┼────┼────┤
│ 4  │ 5  │ 6  │ -  │ x³ │  第6行
├────┼────┼────┼────┼────┤
│ 1  │ 2  │ 3  │ +  │ ∛  │  第7行
├────┼────┼────┼────┼────┤
│ 0  │ .  │(−) │ =  │EXP │  第8行
└────┴────┴────┴────┴────┘
```

### 🎨 determineButtonType() - 确定按钮类型

```java
private ButtonType determineButtonType(String text) {
    // 1. 数字和小数点 → 数字键
    if (text.matches("[0-9.]")) {
        return ButtonType.NUMBER;
    }
    
    // 2. 等号 → 等号键
    if (text.equals("=")) {
        return ButtonType.EQUALS;
    }
    
    // 3. 基本运算符 → 运算符键
    if ("+-×÷%".contains(text)) {
        return ButtonType.OPERATOR;
    }
    
    // 4. AC 和 DEL → 特殊功能键
    if (text.equals("AC") || text.equals("DEL")) {
        return ButtonType.SPECIAL;
    }
    
    // 5. 其他 → 函数键
    return ButtonType.FUNCTION;
}
```

**正则表达式解释：**
```java
"[0-9.]"  // 匹配：
// [0-9] → 任意数字 0-9
// .     → 小数点

// 示例：
"5".matches("[0-9.]")    // true
".".matches("[0-9.]")    // true
"sin".matches("[0-9.]")  // false
```

### 🖱️ createStyledButton() - 创建样式化按钮

```java
private JButton createStyledButton(String text, ButtonType type) {
    // 1. 创建按钮对象
    JButton button = new JButton(text);
    
    // 2. 设置字体和外观
    button.setFont(new Font("Arial", Font.BOLD, 13));
    button.setFocusPainted(false);  // 不显示焦点框
    button.setCursor(new Cursor(Cursor.HAND_CURSOR));  // 手型光标
    
    // 3. 根据类型设置颜色
    Color bgColor;
    if (type == ButtonType.NUMBER) {
        bgColor = new Color(75, 75, 75);      // 深灰色
    } else if (type == ButtonType.OPERATOR) {
        bgColor = new Color(200, 100, 40);    // 橙色
    } else if (type == ButtonType.FUNCTION) {
        bgColor = new Color(40, 100, 180);    // 蓝色
    } else if (type == ButtonType.SPECIAL) {
        bgColor = new Color(180, 40, 40);     // 红色
    } else if (type == ButtonType.EQUALS) {
        bgColor = new Color(40, 150, 40);     // 绿色
    } else {
        bgColor = new Color(120, 40, 150);    // 紫色（内存）
    }
    
    // 4. 应用颜色
    button.setBackground(bgColor);
    button.setForeground(Color.WHITE);  // 白色文字
    button.setBorder(new EmptyBorder(8, 12, 8, 12));  // 内边距
    
    // 5. 添加鼠标悬停效果
    button.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseEntered(MouseEvent e) {
            // 鼠标进入 → 颜色变亮
            button.setBackground(bgColor.brighter());
        }
        
        @Override
        public void mouseExited(MouseEvent e) {
            // 鼠标离开 → 恢复原色
            button.setBackground(bgColor);
        }
    });
    
    // 6. 添加点击事件
    button.addActionListener(e -> handleButtonClick(text));
    
    return button;
}
```

**Color.brighter() 原理：**
```java
// 原始颜色
Color original = new Color(100, 100, 100);

// 变亮（每个 RGB 值 × 1.4）
Color brighter = original.brighter();
// 结果: (140, 140, 140)

// 变暗
Color darker = original.darker();
// 结果: (70, 70, 70)
```

### ⚙️ handleButtonClick() - 处理按钮点击

```java
private void handleButtonClick(String text) {
    // 1. 获取当前显示内容
    String current = display.getText().trim();
    
    // 2. 根据按钮文本执行不同操作
    if (text.equals("AC")) {
        // 全部清除
        display.setText("0");
        statusLabel.setText("DEG | M: " + engine.getMemory());
        
    } else if (text.equals("DEL")) {
        // 删除最后一个字符
        if (current.length() > 1) {
            display.setText(current.substring(0, current.length() - 1));
        } else {
            display.setText("0");
        }
        
    } else if (text.equals("=")) {
        // 计算结果
        try {
            String result = engine.calculate(current);
            display.setText(result);
            statusLabel.setText("DEG | M: " + engine.getMemory());
        } catch (Exception ex) {
            display.setText("错误: " + ex.getMessage());
        }
        
    } else if (text.equals("ANS")) {
        // 插入上次结果
        if (current.equals("0")) {
            display.setText(engine.getLastAnswer());
        } else {
            display.setText(current + engine.getLastAnswer());
        }
        
    } else if (text.equals("MC")) {
        // 清除内存
        engine.memoryClear();
        statusLabel.setText("DEG | M: 0");
        
    } else if (text.equals("MR")) {
        // 读取内存
        display.setText(String.valueOf(engine.memoryRecall()));
        
    } else if (text.equals("M+") || text.equals("M-") || text.equals("MS")) {
        // 内存运算
        try {
            double val = Double.parseDouble(current);
            if (text.equals("M+")) {
                engine.memoryAdd(val);
            } else if (text.equals("M-")) {
                engine.memorySubtract(val);
            } else {
                engine.memoryStore(val);
            }
            statusLabel.setText("DEG | M: " + engine.getMemory());
        } catch (NumberFormatException ex) {
            display.setText("错误: 无效数字");
        }
        
    } else {
        // 默认：追加文本
        if (current.equals("0") || current.startsWith("错误")) {
            display.setText(text);
        } else {
            display.setText(current + text);
        }
    }
}
```

**执行流程示例：**
```
用户点击 "7" 按钮
    ↓
触发 ActionListener
    ↓
调用 handleButtonClick("7")
    ↓
检查 text.equals("7") → 进入 else 分支
    ↓
current = "0" → 显示 "7"
```

### 🔢 createMatrixPanel() - 创建矩阵面板

```java
private JPanel createMatrixPanel() {
    // 1. 创建主面板
    JPanel panel = new JPanel(new BorderLayout(10, 10));
    panel.setBackground(new Color(40, 40, 40));
    panel.setBorder(new EmptyBorder(12, 12, 12, 12));
    
    // 2. 创建矩阵输入区域（并排显示）
    JPanel matricesPanel = new JPanel(new GridLayout(1, 2, 15, 0));
    matricesPanel.setBackground(new Color(40, 40, 40));
    
    // 3. 添加两个矩阵输入面板
    matricesPanel.add(createMatrixInput("矩阵 A", matrixAFields));
    matricesPanel.add(createMatrixInput("矩阵 B", matrixBFields));
    
    // 4. 创建操作按钮（2行3列）
    JPanel opsPanel = new JPanel(new GridLayout(2, 3, 6, 6));
    opsPanel.setBackground(new Color(40, 40, 40));
    opsPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
    
    String[] operations = {"A + B", "A - B", "A × B", "det(A)", "A⁻¹", "Aᵀ"};
    
    for (String op : operations) {
        JButton btn = createStyledButton(op, ButtonType.OPERATOR);
        // 为每个按钮添加矩阵运算的点击事件
        btn.addActionListener(e -> performMatrixOperation(op));
        opsPanel.add(btn);
    }
    
    panel.add(matricesPanel, BorderLayout.CENTER);
    panel.add(opsPanel, BorderLayout.SOUTH);
    
    return panel;
}
```

**布局效果：**
```
┌──────────────────────────────────────┐
│  ┌───────────┐    ┌───────────┐     │
│  │  矩阵 A   │    │  矩阵 B   │     │  CENTER
│  │ [  ] [  ] │    │ [  ] [  ] │     │
│  │ [  ] [  ] │    │ [  ] [  ] │     │
│  └───────────┘    └───────────┘     │
├──────────────────────────────────────┤
│  [A+B] [A-B] [A×B]                  │  SOUTH
│  [det] [A⁻¹] [Aᵀ]                   │
└──────────────────────────────────────┘
```

### 📊 createMatrixInput() - 创建矩阵输入框

```java
private JPanel createMatrixInput(String title, JTextField[][] fields) {
    // 1. 创建带标题的面板
    JPanel panel = new JPanel(new BorderLayout(8, 8));
    panel.setBackground(new Color(55, 55, 55));
    
    // 2. 设置标题边框
    panel.setBorder(new TitledBorder(
        new LineBorder(Color.GRAY, 2),  // 边框线
        title,                           // 标题文字
        TitledBorder.LEFT,              // 左对齐
        TitledBorder.TOP,               // 顶部
        new Font("Arial", Font.BOLD, 14), // 字体
        Color.WHITE                      // 颜色
    ));
    
    // 3. 创建 3×3 网格面板
    JPanel gridPanel = new JPanel(new GridLayout(3, 3, 6, 6));
    gridPanel.setBackground(new Color(55, 55, 55));
    gridPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
    
    // 4. 创建 9 个输入框（3行 × 3列）
    for (int i = 0; i < 3; i++) {           // 行
        for (int j = 0; j < 3; j++) {       // 列
            // 创建文本框
            fields[i][j] = new JTextField("0");
            fields[i][j].setFont(new Font("Consolas", Font.BOLD, 16));
            fields[i][j].setHorizontalAlignment(JTextField.CENTER);
            fields[i][j].setBackground(new Color(70, 70, 70));
            fields[i][j].setForeground(Color.WHITE);
            fields[i][j].setCaretColor(Color.WHITE);
            
            // 添加到网格
            gridPanel.add(fields[i][j]);
        }
    }
    
    panel.add(gridPanel, BorderLayout.CENTER);
    return panel;
}
```

**二维数组索引说明：**
```java
fields[i][j]
       ↑  ↑
       行 列

fields[0][0]  fields[0][1]  fields[0][2]
fields[1][0]  fields[1][1]  fields[1][2]
fields[2][0]  fields[2][1]  fields[2][2]

// 对应矩阵：
┌                    ┐
│ [0][0]  [0][1]  [0][2] │
│ [1][0]  [1][1]  [1][2] │
│ [2][0]  [2][1]  [2][2] │
└                    ┘
```

### 🧮 performMatrixOperation() - 执行矩阵运算

```java
private void performMatrixOperation(String operation) {
    try {
        // 1. 从输入框读取矩阵数据
        double[][] matrixA = readMatrix(matrixAFields);
        double[][] matrixB = readMatrix(matrixBFields);
        
        // 2. 调用矩阵计算器执行运算
        String result = MatrixCalculator.performOperation(
            operation,   // 运算类型
            matrixA,     // 矩阵 A
            matrixB      // 矩阵 B
        );
        
        // 3. 显示结果
        display.setText(result);
        
    } catch (Exception ex) {
        // 4. 错误处理
        display.setText("矩阵错误: " + ex.getMessage());
    }
}
```

**执行流程：**
```
用户点击 "A + B"
    ↓
performMatrixOperation("A + B")
    ↓
readMatrix(matrixAFields) → [[1,2,3], [4,5,6], [7,8,9]]
readMatrix(matrixBFields) → [[9,8,7], [6,5,4], [3,2,1]]
    ↓
MatrixCalculator.performOperation(...)
    ↓
结果显示在 display
```

### 📖 readMatrix() - 读取矩阵数据

```java
private double[][] readMatrix(JTextField[][] fields) throws NumberFormatException {
    // 创建 3×3 二维数组存储矩阵
    double[][] matrix = new double[3][3];
    
    // 遍历所有输入框
    for (int i = 0; i < 3; i++) {           // 行循环
        for (int j = 0; j < 3; j++) {       // 列循环
            // 读取文本框的值并转换为 double
            String text = fields[i][j].getText().trim();
            matrix[i][j] = Double.parseDouble(text);
        }
    }
    
    return matrix;
}
```

**异常处理说明：**
```java
// 如果用户输入 "abc"
Double.parseDouble("abc")  // 抛出 NumberFormatException

// try-catch 捕获异常
try {
    double val = Double.parseDouble("abc");
} catch (NumberFormatException ex) {
    System.out.println("输入不是有效数字！");
}
```

---

## CalculatorEngine 计算引擎详解

### 📋 类成员变量

```java
public class CalculatorEngine {
    // 内存存储器（M 键功能）
    private double memory = 0;
    
    // 上次计算结果（ANS 键功能）
    private String lastAnswer = "0";
}
```

### 🧮 calculate() - 核心计算方法

```java
public String calculate(String expression) throws Exception {
    // 1. 输入验证
    if (expression == null || expression.trim().isEmpty()) {
        throw new IllegalArgumentException("表达式不能为空");
    }
    
    // 2. 预处理表达式（替换特殊符号）
    expression = preprocessExpression(expression);
    
    try {
        // 3. 使用 exp4j 库解析表达式
        Expression exp = new ExpressionBuilder(expression).build();
        
        // 4. 计算结果
        double result = exp.evaluate();
        
        // 5. 检查结果有效性
        if (Double.isNaN(result)) {
            throw new ArithmeticException("结果未定义");
        }
        if (Double.isInfinite(result)) {
            throw new ArithmeticException("结果为无穷大");
        }
        
        // 6. 格式化并保存结果
        lastAnswer = formatResult(result);
        return lastAnswer;
        
    } catch (Exception e) {
        throw new Exception("计算错误: " + e.getMessage());
    }
}
```

**执行流程示例：**
```
输入: "2 + 3 × 4"
    ↓
preprocessExpression() → "2 + 3 * 4"
    ↓
ExpressionBuilder 解析 → 表达式树
                         +
                        / \
                       2   ×
                          / \
                         3   4
    ↓
evaluate() → 14
    ↓
formatResult(14) → "14"
```

### 🔄 preprocessExpression() - 预处理表达式

```java
private String preprocessExpression(String expr) {
    // 1. 替换乘号（× → *）
    expr = expr.replace("×", "*");
    
    // 2. 替换除号（÷ → /）
    expr = expr.replace("÷", "/");
    
    // 3. 替换圆周率（π → 3.141592...）
    expr = expr.replace("π", String.valueOf(Math.PI));
    
    // 4. 替换自然对数底（e → 2.718281...）
    expr = expr.replace("e", String.valueOf(Math.E));
    
    // 5. 替换负号（(−) → (-1)）
    expr = expr.replace("(−)", "(-1)");
    
    return expr;
}
```

**替换原因：**
```java
// exp4j 库只认识标准符号
"2 × 3"  // ❌ exp4j 不认识 ×
"2 * 3"  // ✅ 正确

// 常数替换
"π"      // ❌ 字符串
"3.141592653589793"  // ✅ 数字
```

### 🎨 formatResult() - 格式化结果

```java
private String formatResult(double result) {
    // 1. 检查是否为整数
    if (Math.abs(result - Math.round(result)) < 1e-10) {
        // 是整数 → 显示为长整型
        return String.valueOf((long) Math.round(result));
    }
    
    // 2. 小数 → 格式化为 6 位小数
    return String.format("%.6f", result)
        .replaceAll("0+$", "")      // 去掉末尾的 0
        .replaceAll("\\.$", "");    // 去掉末尾的小数点
}
```

**格式化示例：**
```java
formatResult(10.0)      // "10"     (整数)
formatResult(10.5)      // "10.5"   (去掉末尾0)
formatResult(3.141592)  // "3.141592"
formatResult(0.100000)  // "0.1"    (去掉末尾0)
```

**正则表达式解释：**
```java
"0+$"    // 匹配末尾的一个或多个 0
         // 0+ → 一个或多个 0
         // $  → 字符串末尾

"\\.$"   // 匹配末尾的小数点
         // \\. → 转义的点（.在正则中是特殊字符）
         // $   → 字符串末尾

// 示例：
"10.500000".replaceAll("0+$", "")   // "10.5"
"10.".replaceAll("\\.$", "")         // "10"
```

### 🔍 solveEquation() - 方程求解

```java
public String solveEquation(String equation) throws Exception {
    // 1. 验证方程格式
    if (!equation.contains("=")) {
        throw new IllegalArgumentException("方程必须包含等号");
    }
    
    // 2. 分割方程（按 = 分割）
    String[] parts = equation.split("=");
    if (parts.length != 2) {
        throw new IllegalArgumentException("方程格式错误");
    }
    
    // 3. 提取左右两边
    String left = parts[0].trim();   // 左边表达式
    String right = parts[1].trim();  // 右边表达式
    
    // 4. 数值求解法（暴力搜索）
    for (double x = -100; x <= 100; x += 0.1) {
        try {
            // 4.1 替换 x 为具体值
            String leftExpr = left.replace("x", "(" + x + ")");
            String rightExpr = right.replace("x", "(" + x + ")");
            
            // 4.2 计算左右两边的值
            Expression expLeft = new ExpressionBuilder(leftExpr).build();
            Expression expRight = new ExpressionBuilder(rightExpr).build();
            
            double valLeft = expLeft.evaluate();
            double valRight = expRight.evaluate();
            
            // 4.3 检查是否相等（误差 < 0.001）
            if (Math.abs(valLeft - valRight) < 0.001) {
                return "解: x ≈ " + formatResult(x);
            }
        } catch (Exception ignored) {
            // 某些 x 值可能导致计算错误（如除以0），忽略继续
        }
    }
    
    // 5. 未找到解
    return "在范围 [-100, 100] 内未找到解";
}
```

**求解流程示例：**
```
方程: 2*x + 3 = 7
    ↓
分割: left = "2*x + 3", right = "7"
    ↓
x = -100 → 计算左边 = -197, 右边 = 7  ❌ 不相等
x = -99.9 → ...                      ❌
...
x = 2.0 → 计算左边 = 7, 右边 = 7     ✅ 相等！
    ↓
返回 "解: x ≈ 2"
```

**为什么用 0.1 步长？**
```java
for (double x = -100; x <= 100; x += 0.1)
// 步长太大 → 可能跳过解
// 步长太小 → 计算时间长

// 步长 0.1 的搜索次数：
// (-100 到 100) ÷ 0.1 = 2000 次
// 对于现代计算机，这个次数可以接受
```

### 💾 内存操作方法

```java
// 清除内存
public void memoryClear() {
    memory = 0;
}

// 读取内存
public double memoryRecall() {
    return memory;
}

// 内存加法
public void memoryAdd(double value) {
    memory += value;  // memory = memory + value
}

// 内存减法
public void memorySubtract(double value) {
    memory -= value;  // memory = memory - value
}

// 存储到内存
public void memoryStore(double value) {
    memory = value;
}

// 获取内存值（用于显示）
public double getMemory() {
    return memory;
}

// 获取上次结果
public String getLastAnswer() {
    return lastAnswer;
}
```

**内存操作示例：**
```java
// 初始: memory = 0
memoryClear();         // memory = 0

memoryStore(100);      // memory = 100
memoryAdd(50);         // memory = 150
memorySubtract(20);    // memory = 130
memoryRecall();        // 返回 130
```

---

## MatrixCalculator 矩阵计算器详解

### 🧮 performOperation() - 执行矩阵运算

```java
public static String performOperation(
    String operation,      // 运算类型
    double[][] matrixA,    // 矩阵 A
    double[][] matrixB     // 矩阵 B
) {
    try {
        // 1. 将 Java 数组转换为 EJML 矩阵对象
        SimpleMatrix A = new SimpleMatrix(matrixA);
        SimpleMatrix B = new SimpleMatrix(matrixB);
        
        // 2. 用于存储结果的矩阵
        SimpleMatrix result;
        
        // 3. 根据运算类型执行相应操作
        if (operation.equals("A + B")) {
            // 矩阵加法
            result = A.plus(B);
            return matrixToString(result);
            
        } else if (operation.equals("A - B")) {
            // 矩阵减法
            result = A.minus(B);
            return matrixToString(result);
            
        } else if (operation.equals("A × B")) {
            // 矩阵乘法
            result = A.mult(B);
            return matrixToString(result);
            
        } else if (operation.equals("det(A)")) {
            // 行列式
            double det = A.determinant();
            return "det(A) = " + String.format("%.4f", det);
            
        } else if (operation.equals("A⁻¹")) {
            // 逆矩阵
            result = A.invert();
            return matrixToString(result);
            
        } else if (operation.equals("Aᵀ")) {
            // 转置矩阵
            result = A.transpose();
            return matrixToString(result);
        }
        
        return "未知操作";
        
    } catch (Exception e) {
        return "错误: " + e.getMessage();
    }
}
```

**矩阵运算数学原理：**

```
1. 矩阵加法（对应元素相加）
   [1 2]   [5 6]   [1+5 2+6]   [6  8]
   [3 4] + [7 8] = [3+7 4+8] = [10 12]

2. 矩阵减法（对应元素相减）
   [5 6]   [1 2]   [5-1 6-2]   [4 4]
   [7 8] - [3 4] = [7-3 8-4] = [4 4]

3. 矩阵乘法（行×列）
   [1 2]   [5 6]   [1×5+2×7  1×6+2×8]   [19 22]
   [3 4] × [7 8] = [3×5+4×7  3×6+4×8] = [43 50]

4. 行列式（det）
   det([1 2]) = 1×4 - 2×3 = -2
      [3 4]

5. 逆矩阵（A⁻¹）
   A × A⁻¹ = I（单位矩阵）
   
6. 转置（Aᵀ）- 行列互换
   [1 2 3]ᵀ   [1 4]
   [4 5 6]  = [2 5]
              [3 6]
```

### 📝 matrixToString() - 矩阵转字符串

```java
private static String matrixToString(SimpleMatrix matrix) {
    StringBuilder sb = new StringBuilder();
    
    // 遍历矩阵的每一行
    for (int i = 0; i < matrix.numRows(); i++) {
        sb.append("[");
        
        // 遍历当前行的每一列
        for (int j = 0; j < matrix.numCols(); j++) {
            // 获取元素值并格式化（保留2位小数）
            double value = matrix.get(i, j);
            sb.append(String.format("%.2f", value));
            
            // 如果不是最后一列，添加逗号
            if (j < matrix.numCols() - 1) {
                sb.append(", ");
            }
        }
        
        sb.append("]\n");  // 行结束，换行
    }
    
    return sb.toString();
}
```

**StringBuilder 说明：**
```java
// 为什么不用 String 直接拼接？
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // ❌ 每次都创建新对象，效率低
}

// 使用 StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);  // ✅ 在原对象上修改，效率高
}
String result = sb.toString();
```

**输出格式示例：**
```java
// 矩阵：
// [1.5  2.3]
// [3.7  4.1]

// 输出字符串：
[1.50, 2.30]
[3.70, 4.10]
```

---

## GraphPlotter 图形绘制器详解

### 📊 构造函数 - 创建图形窗口

```java
public class GraphPlotter extends JFrame {
    
    public GraphPlotter(String function) {
        // 1. 设置窗口属性
        setTitle("函数图形: " + function);
        setSize(800, 600);
        setLocationRelativeTo(null);  // 居中显示
        
        // 2. 创建数据系列（存储 x-y 坐标点）
        XYSeries series = new XYSeries(function);
        
        try {
            // 3. 计算函数值（x 从 -10 到 10，步长 0.1）
            for (double x = -10; x <= 10; x += 0.1) {
                // 3.1 创建表达式并设置变量 x
                Expression exp = new ExpressionBuilder(function)
                    .variable("x")       // 声明变量
                    .build()
                    .setVariable("x", x); // 设置 x 的值
                
                // 3.2 计算 y 值
                double y = exp.evaluate();
                
                // 3.3 验证结果（过滤无效值）
                if (!Double.isNaN(y) &&          // 不是 NaN
                    !Double.isInfinite(y) &&     // 不是无穷大
                    Math.abs(y) < 1000) {        // 绝对值 < 1000
                    
                    // 3.4 添加点到数据系列
                    series.add(x, y);
                }
            }
        } catch (Exception e) {
            // 4. 错误处理
            JOptionPane.showMessageDialog(
                this,
                "函数解析错误: " + e.getMessage()
            );
        }
        
        // 5. 创建数据集
        XYSeriesCollection dataset = new XYSeriesCollection(series);
        
        // 6. 创建图表
        JFreeChart chart = ChartFactory.createXYLineChart(
            "y = " + function,  // 图表标题
            "x",                // x 轴标签
            "y",                // y 轴标签
            dataset             // 数据集
        );
        
        // 7. 创建图表面板并设置为内容面板
        ChartPanel chartPanel = new ChartPanel(chart);
        chartPanel.setPreferredSize(new Dimension(800, 600));
        setContentPane(chartPanel);
    }
}
```

**绘图流程：**
```
用户输入: "sin(x)"
    ↓
循环: x = -10, -9.9, -9.8, ..., 9.9, 10
    ↓
每次循环:
  x = -10 → y = sin(-10) = 0.544  ✓ 有效
  x = -9.9 → y = sin(-9.9) = 0.529 ✓ 有效
  ...
    ↓
收集所有 (x, y) 点
    ↓
JFreeChart 绘制曲线
    ↓
显示图形窗口
```

**为什么过滤 y 值？**
```java
// 1. NaN (Not a Number) - 未定义
sqrt(-1)  // NaN

// 2. Infinite - 无穷大
1 / 0     // Infinity

// 3. 值太大
exp(1000) // 超出显示范围

// 过滤条件：
if (!Double.isNaN(y) &&          // 排除 NaN
    !Double.isInfinite(y) &&     // 排除无穷
    Math.abs(y) < 1000) {        // 排除超大值
    series.add(x, y);             // 只添加有效点
}
```

---

## 关键技术深入解析

### 1. exp4j 表达式解析原理

**什么是 exp4j？**
- 一个轻量级的数学表达式解析库
- 可以将字符串表达式转换为可计算的对象

**基本用法：**
```java
// 1. 简单表达式
Expression exp = new ExpressionBuilder("2 + 3").build();
double result = exp.evaluate();  // 5.0

// 2. 带变量的表达式
Expression exp = new ExpressionBuilder("x * 2 + y")
    .variables("x", "y")  // 声明变量
    .build()
    .setVariable("x", 10)  // x = 10
    .setVariable("y", 5);  // y = 5
double result = exp.evaluate();  // 25.0

// 3. 带函数的表达式
Expression exp = new ExpressionBuilder("sin(x) + cos(x)")
    .variables("x")
    .build()
    .setVariable("x", Math.PI / 4);
double result = exp.evaluate();  // 1.414...
```

**解析过程（简化版）：**
```
"2 + 3 * 4"
    ↓ 词法分析
[2] [+] [3] [*] [4]
    ↓ 语法分析
        +
       / \
      2   *
         / \
        3   4
    ↓ 计算
2 + (3 * 4) = 14
```

### 2. EJML 矩阵库原理

**EJML (Efficient Java Matrix Library)**
- 高性能的 Java 矩阵运算库
- 针对矩阵运算进行了优化

**SimpleMatrix 类：**
```java
// 1. 创建矩阵